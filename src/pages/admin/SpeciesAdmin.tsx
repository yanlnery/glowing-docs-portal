import React, { useState, useEffect, useCallback } from 'react';
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle
} from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Plus } from 'lucide-react';
import { useToast } from '@/components/ui/use-toast';
import { Species } from '@/types/species';
import { SpeciesTable } from '@/components/admin/species/SpeciesTable';
import { SpeciesDialog } from '@/components/admin/species/SpeciesDialog';
import { supabase } from '@/integrations/supabase/client';
import { useAdminAuth } from '@/contexts/AdminAuthContext'; // For checking auth state

const generateSlug = (name: string) => {
  if (!name) return '';
  return name
    .toLowerCase()
    .replace(/\s+/g, '-')
    .replace(/[^\w-]+/g, '');
};

const BUCKET_NAME = 'species_images';

export default function SpeciesAdmin() {
  const [species, setSpecies] = useState<Species[]>([]);
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [currentSpecies, setCurrentSpecies] = useState<Species | null>(null);
  const [isNewSpecies, setIsNewSpecies] = useState(false);
  const [imagePreview, setImagePreview] = useState<string | null>(null);
  const [imageFile, setImageFile] = useState<File | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const { toast } = useToast();
  const { isAdminLoggedIn } = useAdminAuth(); // Ensure admin is logged in for operations

  const fetchSpecies = useCallback(async () => {
    setIsLoading(true);
    const { data, error } = await supabase
      .from('species')
      .select('*')
      .order('order', { ascending: true });

    if (error) {
      toast({ title: "Erro ao carregar espécies", description: error.message, variant: "destructive" });
      setSpecies([]);
    } else {
      setSpecies(data as Species[]);
    }
    setIsLoading(false);
  }, [toast]);

  useEffect(() => {
    if (isAdminLoggedIn) { // Only fetch if admin is logged in
      fetchSpecies();
    } else {
      setSpecies([]); // Clear species if not logged in
      setIsLoading(false);
    }
  }, [fetchSpecies, isAdminLoggedIn]);

  const openNewSpeciesDialog = () => {
    setCurrentSpecies({
      id: '', // Will be generated by DB or set before insert
      name: '',
      commonName: '',
      description: 'Descrição detalhada a ser preenchida.',
      characteristics: [''],
      curiosities: [''],
      image: '',
      type: 'serpente',
      slug: '',
      order: species.length > 0 ? Math.max(...species.map(s => s.order || 0)) + 1 : 1,
      // created_at and updated_at will be set by DB
    });
    setIsNewSpecies(true);
    setImagePreview(null);
    setImageFile(null);
    setIsDialogOpen(true);
  };

  const openEditSpeciesDialog = (speciesData: Species) => {
    setCurrentSpecies(speciesData);
    setIsNewSpecies(false);
    setImagePreview(null); 
    setImageFile(null);
    setIsDialogOpen(true);
  };

  const handleImageChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files[0]) {
      const file = e.target.files[0];
      setImageFile(file);
      const reader = new FileReader();
      reader.onloadend = () => {
        setImagePreview(reader.result as string);
      };
      reader.readAsDataURL(file);
      e.target.value = '';
    }
  };
  
  const handleRemoveImage = () => {
    setImagePreview(null);
    setImageFile(null);
    if (currentSpecies) {
      setCurrentSpecies({ ...currentSpecies, image: '' }); 
    }
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
    const { name, value } = e.target;
    if (currentSpecies) {
      let processedValue: string | number | undefined = value;
      if (name === 'order') {
        processedValue = parseInt(value, 10);
        if (isNaN(processedValue as number)) processedValue = currentSpecies.order; // keep old if invalid
      }
      setCurrentSpecies({
        ...currentSpecies,
        [name]: processedValue
      });
    }
  };

  const createArrayHandler = (fieldName: 'characteristics' | 'curiosities') => ({
    handleChange: (index: number, value: string) => {
      if (currentSpecies) {
        const updatedArray = [...currentSpecies[fieldName]];
        updatedArray[index] = value;
        setCurrentSpecies({ ...currentSpecies, [fieldName]: updatedArray });
      }
    },
    handleAdd: () => {
      if (currentSpecies) {
        setCurrentSpecies({ ...currentSpecies, [fieldName]: [...currentSpecies[fieldName], ''] });
      }
    },
    handleRemove: (index: number) => {
      if (currentSpecies && currentSpecies[fieldName].length > 1) {
        const updatedArray = currentSpecies[fieldName].filter((_, i) => i !== index);
        setCurrentSpecies({ ...currentSpecies, [fieldName]: updatedArray });
      }
    },
  });

  const characteristicsHandler = createArrayHandler('characteristics');
  const curiositiesHandler = createArrayHandler('curiosities');

  const handleSaveSpecies = async () => {
    if (!currentSpecies || !isAdminLoggedIn) {
      toast({ title: "Acesso Negado", description: "Você precisa estar logado como administrador.", variant: "destructive" });
      return;
    }
    
    if (!currentSpecies.name || !currentSpecies.commonName || !currentSpecies.description) {
      toast({ title: "Erro de validação", description: "Preencha Nome Popular, Nome Científico e Descrição.", variant: "destructive" });
      return;
    }

    let speciesToSave = { ...currentSpecies };
    if (!speciesToSave.slug) {
      speciesToSave.slug = generateSlug(speciesToSave.name);
    }
    if (!speciesToSave.slug) { // Still no slug (e.g. empty name)
        toast({ title: "Erro de validação", description: "Não foi possível gerar o slug. Verifique o Nome Científico.", variant: "destructive" });
        return;
    }

    let imageUrl = speciesToSave.image; // Keep existing image URL if no new file / no removal

    // Image handling
    if (imageFile) { // New image uploaded
      const fileName = `${Date.now()}-${imageFile.name.replace(/\s+/g, '_')}`;
      const filePath = `public/${fileName}`;

      // Delete old image from Supabase if it exists and a new one is being uploaded
      if (speciesToSave.image && speciesToSave.image.includes(BUCKET_NAME)) {
         const oldImageSupabasePath = speciesToSave.image.split(`${BUCKET_NAME}/`)[1]?.split('?')[0];
         if (oldImageSupabasePath && oldImageSupabasePath !== filePath) {
            await supabase.storage.from(BUCKET_NAME).remove([oldImageSupabasePath]);
         }
      }
      
      const { data: uploadData, error: uploadError } = await supabase.storage
        .from(BUCKET_NAME)
        .upload(filePath, imageFile, { cacheControl: '3600', upsert: true });

      if (uploadError) {
        toast({ title: "Erro no Upload", description: `Falha ao enviar imagem: ${uploadError.message}`, variant: "destructive" });
        return;
      }
      if (uploadData) {
        const { data: publicUrlData } = supabase.storage.from(BUCKET_NAME).getPublicUrl(filePath);
        imageUrl = publicUrlData.publicUrl;
      }
    } else if (speciesToSave.image === '' && currentSpecies.image && currentSpecies.image.includes(BUCKET_NAME)) {
      // Image was explicitly removed by user, and there was an old image in Supabase
      const oldImageSupabasePath = currentSpecies.image.split(`${BUCKET_NAME}/`)[1]?.split('?')[0];
      if (oldImageSupabasePath) {
          await supabase.storage.from(BUCKET_NAME).remove([oldImageSupabasePath]);
      }
      imageUrl = ''; // Ensure image is set to empty string
    }
    
    speciesToSave.image = imageUrl;

    // Prepare data for Supabase (remove id for insert, keep for update)
    const { id, created_at, updated_at, ...dataToUpsert } = speciesToSave;
    
    if (isNewSpecies) {
      const { data, error } = await supabase
        .from('species')
        .insert(dataToUpsert)
        .select()
        .single();
      if (error) {
        toast({ title: "Erro ao adicionar espécie", description: error.message, variant: "destructive" });
        return;
      }
      toast({ title: "Espécie cadastrada", description: `${data.commonName} adicionada com sucesso!` });
    } else {
      const { data, error } = await supabase
        .from('species')
        .update(dataToUpsert)
        .eq('id', id)
        .select()
        .single();
      if (error) {
        toast({ title: "Erro ao atualizar espécie", description: error.message, variant: "destructive" });
        return;
      }
      toast({ title: "Espécie atualizada", description: `${data.commonName} atualizada com sucesso!` });
    }

    await fetchSpecies(); // Refresh list
    setIsDialogOpen(false);
    setImageFile(null);
    setImagePreview(null);
  };

  const handleDeleteSpecies = async (id: string) => {
    if (!isAdminLoggedIn) {
      toast({ title: "Acesso Negado", description: "Você precisa estar logado como administrador.", variant: "destructive" });
      return;
    }
    const speciesToDelete = species.find(s => s.id === id);
    if (!speciesToDelete) return;

    const confirmed = window.confirm("Tem certeza que deseja excluir esta espécie? Esta ação não pode ser desfeita.");
    if (!confirmed) return;

    // Delete image from Supabase Storage
    if (speciesToDelete.image && speciesToDelete.image.includes(BUCKET_NAME)) {
      const imagePath = speciesToDelete.image.split(`${BUCKET_NAME}/`)[1]?.split('?')[0];
      if (imagePath) {
        const { error: deleteImageError } = await supabase.storage.from(BUCKET_NAME).remove([imagePath]);
        if (deleteImageError) {
          toast({ title: "Erro ao remover imagem", description: deleteImageError.message, variant: "destructive" });
          // Decide if you want to stop or proceed with DB deletion
        }
      }
    }

    // Delete species from database
    const { error: deleteDbError } = await supabase.from('species').delete().eq('id', id);
    if (deleteDbError) {
      toast({ title: "Erro ao excluir espécie do BD", description: deleteDbError.message, variant: "destructive" });
      return;
    }

    toast({ title: "Espécie removida", description: "A espécie foi removida com sucesso!" });
    await fetchSpecies(); // Refresh list
  };

  const handleMove = async (currentIndex: number, direction: 'up' | 'down') => {
    const newSpeciesList = [...species];
    const itemToMove = newSpeciesList[currentIndex];
    const targetIndex = direction === 'up' ? currentIndex - 1 : currentIndex + 1;

    if (targetIndex < 0 || targetIndex >= newSpeciesList.length) return;
    
    const itemAtTarget = newSpeciesList[targetIndex];

    // Swap orders
    const newOrderCurrent = itemAtTarget.order;
    const newOrderTarget = itemToMove.order;

    const updates = [
        supabase.from('species').update({ order: newOrderCurrent }).eq('id', itemToMove.id),
        supabase.from('species').update({ order: newOrderTarget }).eq('id', itemAtTarget.id)
    ];

    const results = await Promise.all(updates);
    const errors = results.filter(res => res.error);

    if (errors.length > 0) {
        errors.forEach(err => toast({ title: "Erro ao reordenar", description: err.error?.message, variant: "destructive"}));
    } else {
        toast({ title: "Ordem atualizada" });
    }
    await fetchSpecies(); // Refresh list to reflect new order
  };
  
  const handleMoveUp = (index: number) => handleMove(index, 'up');
  const handleMoveDown = (index: number) => handleMove(index, 'down');

  if (isLoading && isAdminLoggedIn) {
    return <div className="p-6">Carregando espécies...</div>;
  }
  
  if (!isAdminLoggedIn && !isLoading) {
     return <div className="p-6 text-center">Por favor, <a href="/admin" className="underline text-primary">faça login</a> para gerenciar as espécies.</div>;
  }


  return (
    <div className="p-6">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold">Gerenciar Espécies Criadas</h1>
        <Button onClick={openNewSpeciesDialog}>
          <Plus className="mr-2 h-4 w-4" /> Nova Espécie
        </Button>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Lista de Espécies</CardTitle>
        </CardHeader>
        <CardContent>
          {species.length === 0 ? (
            <div className="text-center py-8">
              <p className="text-muted-foreground">Nenhuma espécie cadastrada.</p>
              <Button onClick={openNewSpeciesDialog} className="mt-4">
                Adicionar Primeira Espécie
              </Button>
            </div>
          ) : (
            <SpeciesTable
              speciesList={species}
              onEdit={openEditSpeciesDialog}
              onDelete={handleDeleteSpecies}
              onMoveUp={handleMoveUp}
              onMoveDown={handleMoveDown}
            />
          )}
        </CardContent>
      </Card>

      {currentSpecies && (
        <SpeciesDialog
          isOpen={isDialogOpen}
          onOpenChange={setIsDialogOpen}
          isNewSpecies={isNewSpecies}
          currentSpeciesData={currentSpecies}
          onSave={handleSaveSpecies}
          onInputChange={handleInputChange}
          onCharacteristicChange={characteristicsHandler.handleChange}
          onAddCharacteristic={characteristicsHandler.handleAdd}
          onRemoveCharacteristic={characteristicsHandler.handleRemove}
          onCuriosityChange={curiositiesHandler.handleChange}
          onAddCuriosity={curiositiesHandler.handleAdd}
          onRemoveCuriosity={curiositiesHandler.handleRemove}
          imagePreview={imagePreview}
          imageFile={imageFile}
          onImageChange={handleImageChange}
          onRemoveImage={handleRemoveImage}
        />
      )}
    </div>
  );
}
